#include <stdio.h>

// 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；
// 然后，待所有字条加入完毕，每人从箱中取一个字条；
// 最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
// 求没有一个人中奖的概率

// N张字条的所有可能排列自然是N!（分母）。
// 现在的问题就是求N张字条的错排数f(N)（分子）。
// 1. 如果前面N-1个人拿的都不是自己的票，即前N-1个人满足错排，
//    现在又来了一个人，他手里拿的是自己的票。只要他把自己的票与其他N-1个人中的任意一个交换，就可以满足N个人的错排。这时有(N-1)*f(N-1)种方法。
// 2. 如果前N-1个人不满足错排，而第N个人把自己的票与其中一个人交换后恰好满足错排。
//    这种情况发生在原先N-1人中，N-2个人满足错排，有且仅有一个人拿的是自己的票，而第N个人恰好与他做了交换，这时候就满足了错排。
//    又因为前N-1个人中，每个人都有机会拿着自己的票。所以有N-1种交换的可能。故这时有(N-1)*f(N-2)种方法。
// 综上所述：f(N)=(N-1)*[f(N-1)+f(N-2)] 

// http://acm.hdu.edu.cn/showproblem.php?pid=2048

int main() {
    int n, m;
    double count[21] = {0, 0, 1};
    double base[21] = {0, 1, 2};
    for (int j = 3; j < 21; ++j) { // 打表，计算 f(N) 和 N！
        count[j] = (j - 1) * (count[j - 1] + count[j - 2]);
        base[j] = j * base[j - 1];
    }
    while (scanf("%d", &n) != EOF) {
        for (int j = 0; j < n; ++j) {
            scanf("%d", &m);
            printf("%.2lf%%\n", (count[m] / base[m]) * 100);
        }

    }

    return 0;
}