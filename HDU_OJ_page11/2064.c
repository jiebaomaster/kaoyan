/*
 * 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。
 * 现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。
 * Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？
 * 解：
 * 最重要的就是将除了最大盘子以外的所有盘子从最左边移到最右边和从最右边移到最左边是一样的步骤
 * 令 f(n) 为将n个盘子按规则从左移到右的次数，最大的为第 n 个盘子，则将除了最大的第 n 个盘子，从左移到右需要 f(n-1)，
 * 此时可讲第 n 个盘子移到中间，所以+1，然后又要把 n-1 个盘子从最右边移到最左边，因为中间柱子的第 n 个盘子是最大的，
 * 所以没有影响，还是 f(n-1)，然后第 n 个盘子要移到最右边，所以又+1，最后把 n-1 个盘子从最左边移到最右边，所以又是 f(n-1)
 * 综上，f(n)=3*f(n-1)+2，其中 f(1)=2
 * https://blog.csdn.net/Greatljc/article/details/87966085
 * http://acm.hdu.edu.cn/showproblem.php?pid=2064
 */

#include <stdio.h>

int main() {
    int n;
    while (scanf("%d", &n) != EOF) {
        long long ans = 2;
        for (int i = 1; i < n; ++i) {
            ans = 3 * ans + 2;
        }
        printf("%lld\n", ans);
    }
    return 0;
}